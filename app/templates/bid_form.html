{% from 'macros/_layout.html' import layout %} {% call layout(title='Place Bid -
HuntMaster', current_user=current_user, breadcrumbs=breadcrumbs) %}
<div
    class="bg-gray-800 p-8 rounded-lg shadow-xl w-full max-w-2xl mx-auto border border-gray-700"
>
    <h1 class="text-3xl font-bold text-center text-white mb-6">
        Place Bid for
        <span id="spawnName" class="text-blue-400">{{ spawn_name }}</span>
    </h1>
    <p class="text-sm text-gray-300 mb-8 text-center max-w-md mx-auto">
        Define your preferred hunt duration and then select your availability
        window on the timeline. Finally, set your bid points.
    </p>

    <form id="bidForm" class="space-y-8">
        <!-- Preferred Hunt Duration Slider -->
        <div
            class="p-6 bg-gray-700 rounded-xl shadow-inner border border-gray-600"
        >
            <h3 class="text-lg font-bold text-gray-200 mb-4 text-center">
                Preferred Hunt Duration
            </h3>
            <div class="flex flex-col items-center gap-2">
                {# Use flex-col to stack slider and value #}
                <input
                    type="range"
                    id="preferredDurationSlider"
                    min="0"
                    max="0"
                    value="0"
                    class="w-full max-w-xs"
                />
                <span
                    id="preferredDurationValue"
                    class="text-2xl font-extrabold text-purple-400 mt-2"
                    >--</span
                >
                {# Added mt-2 for spacing #}
            </div>
            <p class="text-sm text-gray-400 mt-2 text-center">
                This sets the minimum length for your time window.
            </p>
        </div>

        <!-- Time Window Widget -->
        <div
            class="p-6 bg-gray-700 rounded-xl shadow-inner border border-gray-600"
        >
            <h3 class="text-lg font-bold text-gray-200 mb-4 text-center">
                Your Availability Window
            </h3>
            <div class="tww-container" id="timeWindowWidget">
                <div class="tww-hour-track">
                    <!-- Hour background bands injected by JS -->
                </div>
                <div class="tww-selection">
                    <div class="tww-resizer tww-resizer-left"></div>
                    <div class="tww-resizer tww-resizer-right"></div>
                </div>
                <div class="tww-time-label"></div>
            </div>
            {# Removed the separate info-display for window start/end #}
        </div>

        <!-- Bid Points Slider -->
        <div
            class="p-6 bg-gray-700 rounded-xl shadow-inner border border-gray-600"
        >
            <h3 class="text-lg font-bold text-gray-200 mb-4 text-center">
                Your Bid Points
            </h3>
            <div class="flex items-center justify-center gap-4">
                <input
                    type="range"
                    id="bidPointsSlider"
                    min="0"
                    max="0"
                    value="0"
                    class="w-full max-w-xs"
                />
                <span
                    id="bidPointsValue"
                    class="text-2xl font-extrabold text-green-400"
                    >--</span
                >
            </div>
            <p class="text-sm text-gray-400 mt-2 text-center">
                Adjust the slider to set your bid points. Higher bids may
                increase your chances!
            </p>
            <p class="text-xs text-gray-400 mt-2 text-center">
                You must bid at least 1/4 of your total points (<span
                    id="minBidPoints"
                    class="font-semibold text-gray-300"
                    >--</span
                >
                pts). Your current points for this spawn:
                <span
                    id="currentSpawnPoints"
                    class="font-semibold text-gray-300"
                    >--</span
                >
            </p>
        </div>

        <div class="mt-10 text-center">
            <button
                type="submit"
                class="px-8 py-3 bg-blue-600 text-white font-bold rounded-full shadow-lg hover:bg-blue-700 transform hover:scale-105 transition duration-300 ease-in-out focus:outline-none focus:ring-4 focus:ring-blue-300"
            >
                Place Bid
            </button>
        </div>
    </form>
</div>

<!-- Link to your external TWW CSS -->
<link rel="stylesheet" href="/static/css/tww.css" />

<!-- Link to your external TWW JavaScript -->
<script src="/static/js/tww.js"></script>

<script>
    // This is a modified version of your original tww.js to support
    // dynamic minimum width and proper Date object returns for external use.
    // It is included here for the purpose of this self-contained demo.
    (function () {
        let externalMinSelectionWidthPx = 0;

        // Expose a global function for the main script to set the minimum width
        window.setTwwMinSelectionWidth = function (widthPx) {
            externalMinSelectionWidthPx = widthPx;
            // Optionally, re-trigger update on all TWW instances if they exist
            document.querySelectorAll(".tww-container").forEach((container) => {
                if (container._twwInstance) {
                    // Check if instance exists
                    container._twwInstance.updateDisplay();
                }
            });
        };

        // Initialize all widgets on page
        const containers = document.querySelectorAll(".tww-container");

        containers.forEach((container) => {
            const selection = container.querySelector(".tww-selection");
            const label = container.querySelector(".tww-time-label");
            const track = container.querySelector(".tww-hour-track");

            const now = new Date();
            const startHour = now.getHours();
            const totalHours = 12; // As per your original tww.js

            // Render hour blocks for this container
            track.innerHTML = "";
            for (let i = 0; i < totalHours; i++) {
                const hour = (startHour + i) % 24;
                const block = document.createElement("div");
                block.classList.add("tww-hour-block");
                const isAM = hour < 12;
                const shade = i % 2 === 0 ? "1" : "2";
                block.classList.add(`tww-${isAM ? "am" : "pm"}${shade}`);
                track.appendChild(block);
            }

            let containerWidth = container.offsetWidth;
            let hourWidth = containerWidth / totalHours;

            // Initial window values (start at 2h, end at 4h)
            let selStart = hourWidth * 2;
            let selEnd = hourWidth * 4;

            // Drag state
            let dragType = null; // 'move', 'resize-left', 'resize-right', 'new-selection'
            let dragStartX = 0;
            let dragStartSelStart = 0;
            let dragStartSelEnd = 0;

            function updateDisplay() {
                selection.style.left = selStart + "px";
                selection.style.width = selEnd - selStart + "px";

                const startHourFloat = (selStart / containerWidth) * totalHours;
                const endHourFloat = (selEnd / containerWidth) * totalHours;

                // Calculate absolute hours based on `startHour` (now.getHours())
                const getAbsoluteTime = (floatHoursOffset) => {
                    const totalMinutes = Math.round(
                        startHour * 60 + floatHoursOffset * 60,
                    );
                    const hours = Math.floor(totalMinutes / 60) % 24;
                    const minutes = totalMinutes % 60;
                    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}`;
                };

                const displayStartAbsolute = getAbsoluteTime(startHourFloat);
                const displayEndAbsolute = getAbsoluteTime(endHourFloat);

                label.textContent = `${displayStartAbsolute} - ${displayEndAbsolute}`;

                // Trigger custom event for external listeners
                const event = new CustomEvent("tww-change", {
                    detail: {
                        start: startHourFloat, // Return float hours relative to TWW's startHour
                        end: endHourFloat, // Return float hours relative to TWW's startHour
                        startAbsolute: displayStartAbsolute, // Also provide formatted strings
                        endAbsolute: displayEndAbsolute,
                    },
                });
                container.dispatchEvent(event);
            }

            function onMouseDown(e) {
                e.preventDefault();
                if (e.target.classList.contains("tww-resizer-left")) {
                    dragType = "resize-left";
                } else if (e.target.classList.contains("tww-resizer-right")) {
                    dragType = "resize-right";
                } else if (e.target === selection) {
                    dragType = "move";
                } else {
                    // If clicking on the track, initiate a new selection
                    dragType = "new-selection";
                    const clickX =
                        e.clientX - container.getBoundingClientRect().left;
                    // Set new selection start to click position, and end to click + min width
                    selStart = Math.max(0, clickX);
                    selEnd = selStart + externalMinSelectionWidthPx; // Use external min width

                    // Ensure new selection doesn't go out of bounds
                    if (selEnd > containerWidth) {
                        selEnd = containerWidth;
                        selStart = selEnd - externalMinSelectionWidthPx;
                        if (selStart < 0) selStart = 0; // Fallback if min width is too large
                    }
                }
                if (dragType) {
                    dragStartX = e.clientX;
                    dragStartSelStart = selStart;
                    dragStartSelEnd = selEnd;
                    document.body.style.userSelect = "none";
                }
                updateDisplay(); // Update immediately for new selection
            }

            function onMouseMove(e) {
                if (!dragType) return;
                const dx = e.clientX - dragStartX;
                const minWidth = externalMinSelectionWidthPx || 40; // Use external min width, fallback to 40px

                if (dragType === "move") {
                    let newStart = Math.min(
                        Math.max(dragStartSelStart + dx, 0),
                        containerWidth - (selEnd - selStart),
                    );
                    selStart = newStart;
                    selEnd = selStart + (dragStartSelEnd - dragStartSelStart);
                } else if (dragType === "resize-left") {
                    let newStart = Math.min(
                        Math.max(dragStartSelStart + dx, 0),
                        selEnd - minWidth, // Enforce min width
                    );
                    selStart = newStart;
                } else if (dragType === "resize-right") {
                    let newEnd = Math.max(
                        Math.min(dragStartSelEnd + dx, containerWidth),
                        selStart + minWidth, // Enforce min width
                    );
                    selEnd = newEnd;
                } else if (dragType === "new-selection") {
                    let currentXRelativeToContainer =
                        e.clientX - container.getBoundingClientRect().left;
                    let newSelEnd = Math.max(
                        selStart + minWidth,
                        Math.min(currentXRelativeToContainer, containerWidth),
                    );
                    selEnd = newSelEnd;
                }
                updateDisplay();
            }

            function onMouseUp() {
                dragType = null;
                document.body.style.userSelect = "";
            }

            // Attach event listeners
            selection.addEventListener("mousedown", onMouseDown);
            container
                .querySelector(".tww-resizer-left")
                .addEventListener("mousedown", onMouseDown);
            container
                .querySelector(".tww-resizer-right")
                .addEventListener("mousedown", onMouseDown);
            track.addEventListener("mousedown", onMouseDown); // Listen on the track for new selections

            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);

            updateDisplay();

            // Expose value getters on container element
            container.twwValue = {
                get start() {
                    const startHourFloat =
                        (selStart / containerWidth) * totalHours;
                    const totalMinutes = Math.round(
                        startHour * 60 + startHourFloat * 60,
                    );
                    // Create a Date object representing the absolute time
                    const absoluteDate = new Date(
                        now.getFullYear(),
                        now.getMonth(),
                        now.getDate(),
                        0,
                        0,
                        0,
                        0,
                    );
                    absoluteDate.setMinutes(totalMinutes);
                    // Adjust date if it wraps to the next day
                    if (totalMinutes >= 24 * 60) {
                        absoluteDate.setDate(absoluteDate.getDate() + 1);
                    }
                    return absoluteDate; // Return Date object
                },
                get end() {
                    const endHourFloat = (selEnd / containerWidth) * totalHours;
                    const totalMinutes = Math.round(
                        startHour * 60 + endHourFloat * 60,
                    );
                    const absoluteDate = new Date(
                        now.getFullYear(),
                        now.getMonth(),
                        now.getDate(),
                        0,
                        0,
                        0,
                        0,
                    );
                    absoluteDate.setMinutes(totalMinutes);
                    // Adjust date if it wraps to the next day
                    if (totalMinutes >= 24 * 60) {
                        absoluteDate.setDate(absoluteDate.getDate() + 1);
                    }
                    return absoluteDate; // Return Date object
                },
                get durationMinutes() {
                    const startMs = container.twwValue.start.getTime();
                    const endMs = container.twwValue.end.getTime();
                    return Math.round((endMs - startMs) / (1000 * 60));
                },
            };

            // Store instance for external access (e.g., for setTwwMinSelectionWidth)
            container._twwInstance = { updateDisplay: updateDisplay };

            // Add a resize observer to update containerWidth if the container size changes
            const resizeObserver = new ResizeObserver((entries) => {
                for (let entry of entries) {
                    if (entry.target === container) {
                        containerWidth = container.offsetWidth;
                        hourWidth = containerWidth / totalHours;
                        updateDisplay(); // Re-render to adapt to new size
                    }
                }
            });
            resizeObserver.observe(container);
        });
    })();

    // Main script for form logic
    document.addEventListener("DOMContentLoaded", () => {
        const spawnNameElement = document.getElementById("spawnName");
        const preferredDurationSlider = document.getElementById(
            "preferredDurationSlider",
        );
        const preferredDurationValue = document.getElementById(
            "preferredDurationValue",
        );
        const bidPointsSlider = document.getElementById("bidPointsSlider");
        const bidPointsValue = document.getElementById("bidPointsValue");
        const minBidPointsDisplay = document.getElementById("minBidPoints");
        const currentSpawnPointsDisplay =
            document.getElementById("currentSpawnPoints");
        // Removed displayWindowStart and displayWindowEnd
        const bidForm = document.getElementById("bidForm");
        const timeWindowWidget = document.getElementById("timeWindowWidget");

        // --- Mock Data (replace with actual backend data in Sprint 0.5.1) ---
        // This data would typically come from your Flask backend template context
        // (e.g., passed from a Python view function).
        const mockSpawnData = {
            name: "{{ spawn_name }}", // Use Jinja2 variable for spawn name
            bidSettings: {
                minClaimDurationMinutes: 15,
                maxClaimDurationMinutes: 180, // 3 hours
            },
            // For now, assume a hardcoded character and its points for this spawn
            currentCharacterSpawnPoints: 1000.0,
        };

        const mockCharacterData = {
            totalPointsForThisSpawn: mockSpawnData.currentCharacterSpawnPoints, // Points specific to this spawn
        };
        // --- End Mock Data ---

        // Populate spawn name (already done by Jinja2, but keeping JS for consistency if dynamic)
        // spawnNameElement.textContent = mockSpawnData.name;
        currentSpawnPointsDisplay.textContent =
            mockCharacterData.totalPointsForThisSpawn;

        // Helper to format minutes into Xh Ym
        function formatMinutesToXhYm(totalMinutes) {
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            if (hours > 0 && minutes > 0) {
                return `${hours}h ${minutes}m`;
            } else if (hours > 0) {
                return `${hours}h`;
            } else {
                return `${minutes}m`;
            }
        }

        // --- Preferred Hunt Duration Slider Logic ---
        preferredDurationSlider.min =
            mockSpawnData.bidSettings.minClaimDurationMinutes;
        preferredDurationSlider.max =
            mockSpawnData.bidSettings.maxClaimDurationMinutes;
        preferredDurationSlider.value =
            mockSpawnData.bidSettings.minClaimDurationMinutes; // Default to min
        const SNAP_INTERVAL_MINUTES = 15;

        function updatePreferredDurationDisplay() {
            let value = parseInt(preferredDurationSlider.value);
            // Snap to nearest SNAP_INTERVAL_MINUTES
            value =
                Math.round(value / SNAP_INTERVAL_MINUTES) *
                SNAP_INTERVAL_MINUTES;
            // Ensure value stays within min/max after snapping
            value = Math.max(
                parseInt(preferredDurationSlider.min),
                Math.min(parseInt(preferredDurationSlider.max), value),
            );
            preferredDurationSlider.value = value; // Update slider thumb position

            preferredDurationValue.textContent = formatMinutesToXhYm(value);

            // Update TWW widget's minimum selection width based on this value
            const twwContainer = document.getElementById("timeWindowWidget");
            if (twwContainer && window.setTwwMinSelectionWidth) {
                // Check if the global function exists
                const twwContainerWidth = twwContainer.offsetWidth;
                const totalHoursTWW = 12; // TWW widget's total hours (from tww.js)
                const millisecondsInHour = 3600000;
                const msPerPxTWW =
                    (totalHoursTWW * millisecondsInHour) / twwContainerWidth;
                const minWidthPxForTWW = (value * 60 * 1000) / msPerPxTWW; // Convert minutes to pixels

                window.setTwwMinSelectionWidth(minWidthPxForTWW);
            }
        }

        preferredDurationSlider.addEventListener(
            "input",
            updatePreferredDurationDisplay,
        );
        // Initial update for preferred duration
        updatePreferredDurationDisplay();

        // --- Bid Points Slider Logic ---
        const minBidPoints = Math.ceil(
            mockCharacterData.totalPointsForThisSpawn / 4,
        );
        bidPointsSlider.min = minBidPoints;
        bidPointsSlider.max = mockCharacterData.totalPointsForThisSpawn;
        bidPointsSlider.value = minBidPoints; // Default to minimum required bid
        minBidPointsDisplay.textContent = minBidPoints;

        function updateBidPointsDisplay() {
            bidPointsValue.textContent = `${bidPointsSlider.value} pts`;
        }

        bidPointsSlider.addEventListener("input", updateBidPointsDisplay);
        // Initial update for bid points
        updateBidPointsDisplay();

        // --- TWW Widget External Display Logic ---
        // The tww.js dispatches a 'tww-change' event, listen for it
        // No longer updating separate displayWindowStart/End elements
        // The tww-time-label inside the widget handles its own display.

        // --- Form Submission Logic ---
        bidForm.addEventListener("submit", (e) => {
            e.preventDefault(); // Prevent actual form submission

            // Get values from TWW widget
            const twwInstance = document.getElementById("timeWindowWidget");
            let huntWindowStartISO = "";
            let huntWindowEndISO = "";

            // Check if twwValue exists and has start/end methods (from our tww.js modifications)
            if (
                twwInstance &&
                twwInstance.twwValue &&
                typeof twwInstance.twwValue.start === "function"
            ) {
                huntWindowStartISO = twwInstance.twwValue.start().toISOString();
                huntWindowEndISO = twwInstance.twwValue.end().toISOString();
            } else {
                console.error("TWW widget twwValue or its methods not found.");
                // Handle error or provide fallback
            }

            const preferredDuration = parseInt(preferredDurationSlider.value);
            const bidPoints = parseInt(bidPointsSlider.value);

            const formData = {
                world_name: "{{ world_name }}",
                spawn_name: "{{ spawn_name }}",
                hunt_window_start: huntWindowStartISO,
                hunt_window_end: huntWindowEndISO,
                preferred_hunt_duration_minutes: preferredDuration,
                bid_points: bidPoints,
            };

            console.log("Bid Form Data Submitted:", formData);
            alert("Bid data logged to console! (Backend integration pending)");
            // In Sprint 0.5.1, this is where you'd make your POST request to /api/bids
        });

        // Initial setup for TWW widget's min width on page load
        window.addEventListener("load", () => {
            const twwContainer = document.getElementById("timeWindowWidget");
            if (
                twwContainer &&
                twwContainer._twwInstance &&
                twwContainer._twwInstance.updateDisplay
            ) {
                twwContainer._twwInstance.updateDisplay();
            }
        });
    });
</script>
{% endcall %}
